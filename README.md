# node-task
> The specification for node-task compliant modules, including the canonical node-task generator.

**WORK IN PROGRESS, FEEDBACK WELCOME**

This project aims to define a stateless, promise-based API for server-side javascript tasks.  Modules which adhere to this specification should be published as stand-alone packages on [npm](http://npmjs.org).  The target for this spec includes file-based tasks, internal CLI front ends, and most exciting of all: plugins for the fantastic javascript build-tool [Grunt](http://gruntjs.com/) (coming with version 0.5+).

Eventually, it is hoped that popular JS libraries will maintain their own node-task modules (think [jshint](https://github.com/jshint), [stylus](https://github.com/learnboost/stylus), [handlebars](https://github.com/wycats/handlebars), etc).  If/when this happens, it will be trivial to pass files through an arbitrary pipeline of interactions and transformations utilizing libraries across the entire npm ecosystem.

While most of the API is focused on making file-based interactions easy, valid tasks need not interact with files at all.  Nor is it necessary to use this project to generate a compliant module (but it it does make it easier by abstracting quite a bit of the work).  Four bare-bones examples of the node-task specification are shown below.

**Examples with object literal assignment:**
```js
// roll your own
module.exports = {
  name: 'nothing',
  description: 'this task does absolutely nothing',
  version: '0.1.0',
  emitter: new (require('eventemitter2').EventEmitter2)({wildcard:true}),
  run: function (config) {
    this.emitter.emit('log', 'i am useless');
  }
};

// using node-task to generate a compliant module
var Task = require('task');
module.exports = Task.create({
  name: 'nothing',
  description: 'this task does absolutely nothing',
  version: '0.1.0',
  method: function (config) {
    this.emit('log', 'i am useless');
  }
});
```

**Examples with property assignment:**
```js
// roll your own
var task = module.exports = {};
task.name = 'nothing';
task.description = 'this task does absolutely nothing';
task.version = '0.1.0';
task.emitter = new (require('eventemitter2').EventEmitter2)({wildcard:true});
task.run = function (config) {
  this.emitter.emit('log', 'i am useless');
};

// using node-task to generate a compliant module
var Task = require('task');
task = {};
task.name = 'nothing';
task.description = 'this task does absolutely nothing';
task.version = '0.1.0';
task.method = function (config) {
  this.emit('log', 'i am useless');
};
module.exports = Task.create(task);
```
The rest of the examples in this document are shown with object literal assignment.  Use whichever you like.

# node-task api

The following properties and methods comprise the public API for modules which implement the node-task specification, excluding any suffixed by **&nsub;** (which are specific to modules generated by this package).

## name
A single word name for task.  Generally utilized by task runners.

## description
A short description of the job the task will perform.

## version
A valid [semver](http://semver.org/) string.

## emitter
An instance of [EventEmitter2](http://github.com/hij1nx/EventEmitter2).  All logging must be emitted through this interface.  Please, no direct console.log!

**TODO:** Enumerate valid events here.

To get started with console debugging, try this:
```js
var Task = require('./lib/task');
var task = Task.create({
  name: 'logging',
  description: 'show how to see events at the console easily',
  method: function(config) {
    this.emit('log', 'hi there');
  }
});
task.emitter.on('log.*', function(message) {
  console.log(this.event, message);
});
task.run({});
```

## type &nsub;
This property is used to signal special handling when `run` is called by modules generated using this package.  Currently supported values and their associated automation are:

### `fileIterator`
* Iterate over all files in config, passing each filepath into user-defined method [`iterateFile`](#iteratefile).

### `fileReader`
* Iterate over all files in config, passing each filepath into user-defined method [`iterateFile`](#iteratefile).
* Read contents of each source file, passing it into user-defined method [`filterRead`](#filterread) for handling.

A typical invocation for `fileIterator` or `fileReader` task will look something like this:
```js
task.run({
  // files to work with
  files: [
    'path/to/input1',
    'path/to/input2',
    'path/to/input3',
    'path/to/input4'
  },
  // task options
  options {
    taskOption: true
  },
  // cli flags
  flags: {
    dryRun: false
  }
})
```

### `fileWriter`
* Iterate over all files in config, passing each filepath into user-defined method [`iterateFile`](#iteratefile).
* Read contents of each source file, passing it into user-defined method [`filterRead`](#filterread) for handling.
* Pass modified contents of all source files into user-defined method [`filterWrite`](#filterwrite) to prepare output.
* Write modified output to destination file.

A typical invocation for a `fileWriter` task will look something like this:
```js
task.run({
  // files to work with
  files: {
    'path/to/dest1': ['path/to/input1', 'path/to/input2'],
    'path/to/dest2': ['path/to/input3', 'path/to/input4']
  },
  // task options
  options {
    taskOption: true
  },
  // cli flags
  flags: {
    dryRun: false
  }
})
```

## run
`task.run(config)`

Execute a task.  If using this package to generate a node-task compliant module, `run` is already defined (please use [`method`](#method-%E2%8A%84) for custom handling).  If the completion of this method is asynchronous, a promise must be returned.

**Example:**
```js
// roll your own
var when = require('when');
module.exports = {
  name: 'run',
  description: 'this task demonstrates what run method should do',
  version: '0.1.0',
  emitter: new (require('eventemitter2').EventEmitter2)({wildcard:true}),
  exception: function (message) {
    // handle exceptions
  },
  setup: function (config) {
    this.emitter.emit('setup', config);
  },
  teardown: function (config) {
    this.emitter.emit('teardown', config);
  },
  run: function (config) {
    var self = this;
    config = self._parseConfig(config);

    return when(self.setup(config)).
           then(function() {
             return self.method(config);
           }).
           then(function() {
             return self.teardown(config);
           }, self.exception);
  }
};
```

## readFile
`task.readFile(config, filepath)`

## writeFile
`task.writeFile(config, input, filepath)`

## parseConfig
`task.parseConfig(config)`

Receives the raw config passed to [`run`](#run), the return value will be used for executing the task.  If configuration modification is required (setting default options, for example), it must occur here.  A `parseConfig` event with matching arguments must be emitted with the raw config before this is called (handled automatically by tasks created with this package).

**Example:**
```js
var Task = require('task');
var _ = require('lodash');

var task = Task.create({
  name: 'parseConfig',
  description: 'example for defining a parseConfig method',
  parseConfig: function (config) {
    config.options = _.extend({defaultSetting:true}, config.options);
    return config;
  }
});
```

## setup
`task.setup(config)`

Any pre-task operations must occur here.  If the completion of this method is asynchronous, a promise must be returned.  A `setup` event with matching arguments must be emitted before this is called (handled automatically by tasks created with this package).

**Example:**
```js
var Task = require('task');
var task = Task.create({
  name: 'setup',
  description: 'example for defining a setup method',
  setup: function (config) {
    var self = this;
    var defer = Task.defer();
    setTimeout(function () {
      self.emit('log', 'setting up for task');
      defer.resolve(true);
    }, 100);
    return defer;
  }
});
```

## method &nsub;
`task.method(config)`

If building a module using this package, but not using one of the built-in [task types](#type-%E2%8A%84), define this to perform an arbitrary task.  If the completion of this method is asynchronous, a promise must be returned.

**Example:**
```js
var Task = require('task');
module.exports = Task.create({
  name: 'method',
  description: 'example of custom task using method',
  version: '0.1.0',
  method: function (config) {
    var defer = Task.defer();
    this.emit('log', 'i am a custom task');
    setTimeout(function () {
      self.emit('log', 'my async behavior has completed');
      defer.resolve(true);
    }, 100);
    return defer;
  }
});
```

## iterateFile
`task.iterateFile(config, filepath)`

Any actions which do not require the task to read the contents of a file must occur here.  If the completion of this method is asynchronous, a promise must be returned.  An `iterateFile` event with matching arguments must be emitted before this is called  (handled automatically by tasks created with this package).

**Example:**
```js
var Task = require('task');
var task = Task.create({
  name: 'iterateFile',
  description: 'example for defining a fileIterator method',
  type: 'fileIterator',
  iterateFile: function (config, filepath) {
    this.emit('log', 'iterated over '+filepath);
  }
});
```

## filterRead
`task.filterRead(config, input, filepath)`

Any actions which operate with the contents of a file as it is read must occur here.  If task will write a file based on the input of another, the return value of this method can be used to modify each incoming file's content.  If the completion of this method is asynchronous, a promise must be returned.  A `filterRead` event with matching arguments must be emitted before this is called (handled automatically by tasks created with this package).

**Example for [`fileReader`](#filereader) type tasks:**
```js
var Task = require('task');
var jshint = require("jshint").JSHINT;
var task = Task.create({
  name: 'jshint',
  description: 'example for a basic linting task',
  type: 'fileReader',
  filterRead: function (config, input, filepath) {
    if (!jshint(input)) {
      this.emit('log', filepath+' failed linting');
    }
  }
});
```

**Example for [`fileWriter`](#filewriter) type tasks:**
```js
var Task = require('task');
var cs = require('coffee-script');
var task = Task.create({
  name: 'coffee-script',
  description: 'example for a basic coffee-script transpiler task',
  type: 'fileReader',
  filterRead: function (config, input, filepath) {
    return cs.compile(input, config.options);
  }
});
```

**Example for [`fileWriter`](#filewriter) type tasks with asynchronous results:**
```js
var Task = require('task');
var stylus = require('stylus');
var task = Task.create({
  name: 'stylus',
  description: 'example for a basic stylus compiler task',
  type: 'fileReader',
  filterRead: function (config, input, filepath) {
    var s = stylus(input);
    var defer = Task.defer();
    s.render(function(err, css) {
      defer.resolve(css);
    });
    return defer;
  }
});
```

## filterWrite
`task.filterWrite(config, input, filepath)`

Any actions which modify the intended content of a destination file should occur here.  The input argument will contain an array of file contents (as modified by [`filterRead`](#filterread), if applicable).  This method should reduce the input array to a string and return the value to be written.  If the completion of this method is asynchronous, a promise must be returned.  A `filterWrite` event with matching arguments must be emitted before this is called (handled automatically by tasks created with this package).

**Example:**
```js
var Task = require('task');
var task = Task.create({
  name: 'concat',
  description: 'example for a basic concat task',
  type: 'fileWriter',
  filterWrite: function (config, input, filepath) {
    return input.join('\n');
  }
});
```

## teardown
`task.teardown(config)`

Any post-task operations must occur here.  If the completion of this method is asynchronous, a promise must be returned.  A `teardown` event with matching arguments must be emitted before this is called (handled automatically by tasks created with this package).

**Example:**
```js
var Task = require('task');
var task = Task.create({
  name: 'teardown',
  description: 'example for defining a teardown method',
  teardown: function (config) {
    var self = this;
    var defer = Task.defer();
    setTimeout(function () {
      self.emit('log', 'tearing down task');
      defer.resolve(true);
    }, 100);
    return defer;
  }
});
```

> Copyright (c) 2013 Tyler Kellen, contributors.  See LICENSE for further details.